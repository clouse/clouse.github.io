<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="内容概要   类与继承 属性与字段 接口 可见性修饰符 扩展 数据类 密封类 泛型 嵌套类 枚举类 对象 委托 委托属性 类和继承类Kotlin 中使用关键字 class 声明类类声明由类名、类头（指定其类型参数、主构造函数等） 和由大括号包围的类体构成。类头和类体都是可选的； 如果一个类没有类体，可以省略花括号   构造函数在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin基础（2）-类与对象">
<meta property="og:url" content="http://yoursite.com/2018/05/23/Kotlin基础（2）-类与对象/index.html">
<meta property="og:site_name" content="Clouse">
<meta property="og:description" content="内容概要   类与继承 属性与字段 接口 可见性修饰符 扩展 数据类 密封类 泛型 嵌套类 枚举类 对象 委托 委托属性 类和继承类Kotlin 中使用关键字 class 声明类类声明由类名、类头（指定其类型参数、主构造函数等） 和由大括号包围的类体构成。类头和类体都是可选的； 如果一个类没有类体，可以省略花括号   构造函数在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。">
<meta property="og:updated_time" content="2018-05-25T08:03:58.053Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin基础（2）-类与对象">
<meta name="twitter:description" content="内容概要   类与继承 属性与字段 接口 可见性修饰符 扩展 数据类 密封类 泛型 嵌套类 枚举类 对象 委托 委托属性 类和继承类Kotlin 中使用关键字 class 声明类类声明由类名、类头（指定其类型参数、主构造函数等） 和由大括号包围的类体构成。类头和类体都是可选的； 如果一个类没有类体，可以省略花括号   构造函数在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/23/Kotlin基础（2）-类与对象/"/>





  <title>Kotlin基础（2）-类与对象 | Clouse</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Clouse</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Accueil
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/23/Kotlin基础（2）-类与对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Clouse">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Clouse">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kotlin基础（2）-类与对象</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posté le</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-23T16:18:25+08:00">
                2018-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>内容概要  </p>
<p><li>类与继承</li></p>
<p><li>属性与字段</li></p>
<p><li>接口</li></p>
<p><li>可见性修饰符</li></p>
<p><li>扩展</li></p>
<p><li>数据类</li></p>
<p><li>密封类</li></p>
<p><li>泛型</li></p>
<p><li>嵌套类</li></p>
<p><li>枚举类</li></p>
<p><li>对象</li></p>
<p><li>委托</li></p>
<p><li>委托属性</li></p>
<h2 id="类和继承"><a href="#类和继承" class="headerlink" title="类和继承"></a>类和继承</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Kotlin 中使用关键字 class 声明类<br>类声明由类名、类头（指定其类型参数、主构造函数等） 和由大括号包围的类体构成。类头<br>和类体都是可选的； 如果一个类没有类体，可以省略花括号  </p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。主构造函数是类头的<br>一部分：它跟在类名（和可选的类型参数） 后。  </p>
<pre>
class Person constructor(firstName: String) {
}
</pre>
如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字。
<pre>
class Person(firstName: String) {
}
</pre>
主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化
块（initializer blocks） 中：  
<pre>
class Customer(name: String) {
    init {
        logger.info("Customer initialized with value ${name}")
    }
}
</pre>
注意，主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使
用：
<pre>
class Customer(name: String) {
    val customerKey = name.toUpperCase()
}
</pre>
事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：
<pre>
class Person(val firstName: String, val lastName: String, var age: Int) {
// ……
}
</pre>
与普通属性一样，主构造函数中声明的属性可以是可变的（var ） 或只读的（val ） 。
如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符
在它前面：  
<pre>
class Customer public @Inject constructor(name: String) { …… }
</pre>

<p><strong>次构造函数</strong><br>类也可以声明前缀有 constructor 的次构造函数：  </p>
<pre>
class Person {
    constructor(parent: Person) {
        parent.children.add(this)
    }
}
</pre>
如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过
别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：
<pre>
class Person(val name: String) {
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}
</pre>
如果一个非抽象类没有声明任何（主或次） 构造函数，它会有一个生成的不带参数的主构造
函数。构造函数的可见性是 public。如果你不希望你的类有一个公有构造函数，你需要声明一
个带有非默认可见性的空的主构造函数：  
<pre>
class DontCreateMe private constructor () {
}
</pre>


<p><strong>创建类的实例</strong><br>要创建一个类的实例，我们就像普通函数一样调用构造函数：  </p>
<pre>
val invoice = Invoice()
val customer = Customer("Joe Smith")
</pre>
注意 Kotlin 并没有 new 关键字。
创建嵌套类、内部类和匿名内部类的类实例在嵌套类中有述  

**类成员**
类可以包含：
<li>构造函数和初始化块
</li><li>函数
</li><li>属性
</li><li>嵌套类和内部类
</li><li>对象声明

### 继承 ###
在 Kotlin 中所有类都有一个共同的超类 Any ，这对于没有超类型声明的类是默认超类：
<pre>
class Example // 从 Any 隐式继承
</pre>
Any 不是 java.lang.Object ；尤其是，它除了 equals() 、 hashCode() 和 toString() 外没
有任何成员。 更多细节请查阅Java互操作性部分。   

要声明一个显式的超类型，我们把类型放到类头的冒号之后：
<pre>
open class Base(p: Int)
class Derived(p: Int) : Base(p)
</pre>
如果该类有一个主构造函数，其基类型可以（并且必须） 用（基类型的） 主构造函数参数就
地初始化。    
如果类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委
托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型
的不同的构造函数：  
<pre>
class MyView : View {
    constructor(ctx: Context) : super(ctx)
    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}
</pre>
类上的 open 标注与 Java 中 final 相反，它允许其他类从这个类继承。默认情况下，在
Kotlin 中所有的类都是 final， 对应于 Effective Java书中的第 17 条：要么为继承而设计，并
提供文档说明，要么就禁止继承。   

**覆盖方法**  
我们之前提到过，Kotlin 力求清晰显式。与 Java 不同，Kotlin 需要显式标注可覆盖的成员
（我们称之为开放） 和覆盖后的成员：  
<pre>
open class Base {
    open fun v() {}
    fun nv() {}
}
class Derived() : Base() {
    override fun v() {}
}
</pre>
Derived.v() 函数上必须加上 override标注。如果没写，编译器将会报错。 如果函数没有标注
open 如 Base.nv() ，则子类中不允许定义相同签名的函数， 不论加不加 override。在一个
final 类中（没有用 open 标注的类） ，开放成员是禁止的。  

标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再
次覆盖，使用 final 关键字：
<pre>
open class AnotherDerived() : Base() {
    final override fun v() {}
}
</pre>
**属性覆盖**与方法覆盖类似；在超类中声明然后在派生类中重新声明的属性必须以 override
开头，并且它们必须具有兼容的类型。每个声明的属性可以由具有初始化器的属性或者具有
getter 方法的属性覆盖。  
<pre>
open class Foo {
    open val x: Int get() { …… }
} 
class Bar1 : Foo() {
    override val x: Int = ……
}
</pre>
你也可以用一个 var 属性覆盖一个 val 属性，但反之则不行。这是允许的，因为一个
val 属性本质上声明了一个 getter 方法，而将其覆盖为 var 只是在子类中额外声明一个
setter 方法。  
请注意，你可以在主构造函数中使用 override 关键字作为属性声明的一部分。
<pre>
interface Foo {
    val count: Int
} 
class Bar1(override val count: Int) : Foo
class Bar2 : Foo {
    override var count: Int = 0
}
</pre>
**调用超类实现**
派生类中的代码可以使用 super 关键字调用其超类的函数与属性访问器的实现：  
<pre>
open class Foo {
open fun f() { println("Foo.f()") }
open val x: Int get() = 1
} 
class Bar : Foo() {
    override fun f() {
        super.f()
        println("Bar.f()")
    } 
override val x: Int get() = super.x + 1
}
</pre>
在一个内部类中访问外部类的超类，可以通过由外部类名限定的 super 关键字来实
现： super@Outer ：  
<pre>
class Bar : Foo() {
    override fun f() { /* …… */ }
    override val x: Int get() = 0
    inner class Baz {
        fun g() {
            super@Bar.f() // 调用 Foo 实现的 f()
            println(super@Bar.x) // 使用 Foo 实现的 x 的 getter
        }
    }
}
</pre>
覆盖规则
在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实
现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一） 。 为了表示采用
从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super ，如 super<base> ：  
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">open class A &#123;  </div><div class="line">	open fun f() &#123; print(&quot;A&quot;) &#125;  </div><div class="line">	fun a() &#123; print(&quot;a&quot;) &#125;  </div><div class="line">&#125;   </div><div class="line">interface B &#123;  </div><div class="line">	fun f() &#123; print(&quot;B&quot;) &#125; // 接口成员默认就是“open”的  </div><div class="line">	fun b() &#123; print(&quot;b&quot;) &#125;  </div><div class="line">&#125;   </div><div class="line">class C() : A(), B &#123;  </div><div class="line">	// 编译器要求覆盖 f()：  </div><div class="line">	override fun f() &#123;  </div><div class="line">		super&lt;A&gt;.f() // 调用 A.f() </div><div class="line">		super&lt;B&gt;.f() // 调用 B.f()  </div><div class="line">	&#125;</div><div class="line">&#125;  </div><div class="line">&lt;/pre&gt;</div></pre></td></tr></table></figure>

同时继承 A 和 B 没问题，并且 a() 和 b() 也没问题因为 C 只继承了每个函数的一个
实现。 但是 f() 由 C 继承了两个实现，所以我们必须在 C 中覆盖 f() 并且提供我们自
己的实现来消除歧义。  

**抽象类**
类和其中的某些成员可以声明为 abstract 。 抽象成员在本类中可以不用实现。 需要注意的
是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻。  
我们可以用一个抽象成员覆盖一个非抽象的开放成员
<pre>
open class Base {
open fun f() {}
} 
abstract class Derived : Base() {
    override abstract fun f()
}
</pre>
#### 伴生对象 ####
与 Java 或 C# 不同，在 Kotlin 中类没有静态方法。在大多数情况下，它建议简单地使用包级
函数。   

如果你需要写一个可以无需用一个类的实例来调用、但需要访问类内部的函数（例如，工厂
方法） ，你可以把它写成该类内对象声明中的一员。  
更具体地讲，如果在你的类内声明了一个伴生对象， 你就可以使用像在 Java/C# 中调用静态
方法相同的语法来调用其成员，只使用类名作为限定符。  
<pre>
val instance = MyClass.create()
</pre>
可以省略伴生对象的名称，在这种情况下将使用名称 Companion ：
请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象
的实例成员，而且，例如还可以实现接口：
<pre>
interface Factory<t> {
    fun create(): T
} 
class MyClass {
    companion object : Factory<myclass> {
        override fun create(): MyClass = MyClass()
    }
}
</myclass></t></pre>
当然，在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静
态方法和字段。更详细信息请参见Java 互操作性一节 。  

### 属性和字段 ###
声明属性  
Kotlin的类可以有属性。 属性可以用关键字 var 声明为可变的，否则使用只读关键字 val 。  
<pre>
class Address {
    var name: String = ……
    var street: String = ……
    var city: String = ……
    var state: String? = ……
    var zip: String = ……
}
</pre>

<p>要使用一个属性，只要用名称引用它即可，就像 Java 中的字段：</p>
<pre>
fun copyAddress(address: Address): Address {
    val result = Address() // Kotlin 中没有“new”关键字
    result.name = address.name // 将调用访问器
    result.street = address.street
    // ……
    return result
}
</pre>
声明一个属性的完整语法是
<pre>
var < propertyName >[: < PropertyType >] [= < property_initializer >]
[< getter >]
[< setter >]
</pre>
其初始器（initializer） 、getter 和 setter 都是可选的。属性类型如果可以从初始器 （或者从
其 getter 返回值，如下文所示） 中推断出来，也可以省略。  
<pre>
var allByDefault: Int? // 错误：需要显式初始化器，隐含默认 getter 和 setter
var initialized = 1 // 类型 Int、默认 getter 和 setter
</pre>
一个只读属性的语法和一个可变的属性的语法有两方面的不同：1、只读属性的用 val 开始
代替 var 2、只读属性不允许 setter
<pre>
val simple: Int? // 类型 Int、默认 getter、必须在构造函数中初始化
val inferredType = 1 // 类型 Int 、默认 getter
</pre>
我们可以编写自定义的访问器，非常像普通函数，刚好在属性声明内部。这里有一个自定义
getter 的例子:
<pre>
val isEmpty: Boolean
get() = this.size == 0

var stringRepresentation: String
get() = this.toString()
set(value) {
    setDataFromString(value) // 解析字符串并赋值给其他属性
}
</pre>
按照惯例，setter 参数的名称是 value ，但是如果你喜欢你可以选择一个不同的名称。  
自 Kotlin 1.1 起，如果可以从 getter 推断出属性类型，则可以省略它  

如果你需要改变一个访问器的可见性或者对其注解，但是不需要改变默认的实现， 你可以定
义访问器而不定义其实现:
<pre>
var setterVisibility: String = "abc"
private set // 此 setter 是私有的并且有默认实现
var setterWithAnnotation: Any? = null
@Inject set // 用 Inject 注解此 setter
</pre>

<p>幕后字段<br>Kotlin 中类不能有字段。然而，当使用自定义访问器时，有时有一个幕后字段（backing<br>field） 有时是必要的。为此 Kotlin 提供一个自动幕后字段，它可通过使用 field 标识符访<br>问。</p>
<pre>
var counter = 0 // 此初始器值直接写入到幕后字段
set(value) {
    if (value >= 0)
        field = value
}
</pre>
field 标识符只能用在属性的访问器内。
如果属性至少一个访问器使用默认实现，或者自定义访问器通过 field 引用幕后字段，将会
为该属性生成一个幕后字段。  

幕后属性
如果你的需求不符合这套“隐式的幕后字段”方案，那么总可以使用 幕后属性（backing
property） ：
<pre>
private var _table: Map<string, int="">? = null
public val table: Map<string, int="">
    get() {
        if (_table == null) {
            _table = HashMap() // 类型参数已推断出
        } 
    return _table ?: throw AssertionError("Set to null by another thread")
}
</string,></string,></pre>
从各方面看，这正是与 Java 相同的方式。因为通过默认 getter 和 setter 访问私有属性会被优
化，所以不会引入函数调用开销。  

#### 编译期常量 ####
已知值的属性可以使用 const 修饰符标记为 编译期常量。 这些属性需要满足以下要求：
</li><li>位于顶层或者是 object 的一个成员
</li><li>用 String 或原生类型 值初始化
</li><li>没有自定义 getter
这些属性可以用在注解中：  
<pre>
const val SUBSYSTEM_DEPRECATED: String = "This subsystem is deprecated"
@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { …… }
</pre>
#### 延迟初始化属性 ####
一般地，属性声明为非空类型必须在构造函数中初始化。 然而，这经常不方便。例如：属性
可以通过依赖注入来初始化， 或者在单元测试的 setup 方法中初始化。 这种情况下，你不能
在构造函数内提供一个非空初始器。 但你仍然想在类体中引用该属性时避免空检查。
为处理这种情况，你可以用 lateinit 修饰符标记该属性：  
<pre>
public class MyTest {
    lateinit var subject: TestSubject
    @SetUp fun setup() {
        subject = TestSubject()
    } 
    @Test fun test() {
        subject.method() // 直接解引用
    }
}
</pre>
该修饰符只能用于在类体中（不是在主构造函数中） 声明的 var 属性，并且仅当该属性没有
自定义 getter 或 setter 时。该属性必须是非空类型，并且不能是原生类型。
在初始化前访问一个 lateinit 属性会抛出一个特定异常，该异常明确标识该属性被访问及
它没有初始化的事实。  
#### 委托属性-具体见后面的详细介绍 ####
最常见的一类属性就是简单地从幕后字段中读取（以及可能的写入） 。 另一方面，使用自定
义 getter 和 setter 可以实现属性的任何行为。 介于两者之间，属性如何工作有一些常见的模
式。一些例子：惰性值、 通过键值从映射读取、访问数据库、访问时通知侦听器等等。
这些常见行为可以通过使用委托属性实现为库。


### 接口 ###
Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接
口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。
使用关键字 interface 来定义接口  
<pre>
interface MyInterface {
    fun bar()
    fun foo() {
        // 可选的方法体
    }
}
</pre>
实现接口  
一个类或者对象可以实现一个或多个接口。  
接口中的属性  
你可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在
接口中声明的属性不能有幕后字段（backing field） ，因此接口中声明的访问器不能引用它
们
<pre>
interface MyInterface {
    val prop: Int // 抽象的
    val propertyWithImplementation: String
    get() = "foo"
    fun foo() {
        print(prop)
    }
}
class Child : MyInterface {
    override val prop: Int = 29
}
</pre>

<p>解决覆盖冲突  </p>
<pre>
interface A {
    fun foo() { print("A") }
    fun bar()
} 
interface B {
    fun foo() { print("B") }
    fun bar() { print("bar") }
} 
class C : A {
    override fun bar() { print("bar") }
} 
class D : A, B {
    override fun foo() {
        super< A >.foo()
        super< B >.foo()
    } 
    override fun bar() {
        super< B >.bar()
    }
}
</pre>
上例中，接口 A 和 B 都定义了方法 foo() 和 bar()。 两者都实现了 foo(), 但是只有 B 实现了
bar() (bar() 在 A 中没有标记为抽象， 因为没有方法体时默认为抽象） 。因为 C 是一个实现了
A 的具体类，所以必须要重写 bar() 并实现这个抽象方法 然而，如果我们从 A 和 B 派生 D，我们需要实现我们从多个接口继承的所有方法，并指明 D
应该如何实现它们。这一规则既适用于继承单个实现（bar()） 的方法也适用于继承多个实现
（foo()） 的方法  

#### 可见性修饰符 ####
类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有 可见性修饰符。 （getter
总是与属性有着相同的可见性。） 在 Kotlin 中有这四个可见性修饰符： private 、
protected 、 internal 和 public 。 如果没有显式指定修饰符的话，默认可见性是
public 。  
##### 包名 #####
函数、属性和类、对象和接口可以在顶层声明，即直接在包内：
</li><li>如果你不指定任何可见性修饰符，默认为 public ，这意味着你的声明将随处可见；
</li><li>如果你声明为 private ，它只会在声明它的文件内可见；
</li><li>如果你声明为 internal ，它会在相同模块内随处可见；
</li><li>protected 不适用于顶层声明。
类和接口  
对于类内部声明的成员：  
</li><li>private 意味着只在这个类内部（包含其所有成员） 可见；
</li><li>protected —— 和 private 一样 + 在子类中可见。
</li><li>internal —— 能见到类声明的 本模块内 的任何客户端都可见其 internal 成员；
</li><li>public —— 能见到类声明的任何客户端都可见其 public 成员  
注意 对于Java用户：Kotlin 中外部类不能访问内部类的 private 成员。
如果你覆盖一个 protected 成员并且没有显式指定其可见性，该成员还会是 protected 可
见性。  
<pre>
open class Outer {
    private val a = 1
    protected open val b = 2
    internal val c = 3
    val d = 4 // 默认 public
protected class Nested {
    public val e: Int = 5
}
} 
class Subclass : Outer() {
    // a 不可见
    // b、c、d 可见
    // Nested 和 e 可见
    override val b = 5 // “b”为 protected
} 
class Unrelated(o: Outer) {
    // o.a、o.b 不可见
    // o.c 和 o.d 可见（相同模块）
    // Outer.Nested 不可见，Nested::e 也不可见
}
</pre>

<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>要指定一个类的的主构造函数的可见性，使用以下语法（注意你需要添加一个显式<br>constructor 关键字） ：</p>
<pre>
class C private constructor(a: Int) { …… }
</pre>
这里的构造函数是私有的。默认情况下，所有构造函数都是 public ，这实际上等于类可见的
地方它就可见（即 一个 internal 类的构造函数只能在相同模块内可见)  

#### 局部声明 ####
局部变量、函数和类不能有可见性修饰符

#### 模块 ####
可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译
在一起的一套 Kotlin 文件：
</li><li>一个 IntelliJ IDEA 模块；
</li><li>一个 Maven 项目；
</li><li>一个 Gradle 源集；
</li><li>一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件

### 扩展 ###
#### 扩展函数 ####
声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。 下面
代码为 MutableList<int> 添加一个 swap 函数：  
<pre>
fun MutableList<int>.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // “this”对应该列表
    this[index1] = this[index2]
    this[index2] = tmp
}
</int></pre>
这个 this 关键字在扩展函数内部对应到接收者对象（传过来的在点符号前的对象） 现在，
我们对任意 MutableList<int> 调用该函数了：  
当然，这个函数对任何 MutableList<t> 起作用，我们可以泛化它：
<pre>
fun <t> MutableList<t>.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // “this”对应该列表
    this[index1] = this[index2]
    this[index2] = tmp
}
</t></t></pre>
为了在接收者类型表达式中使用泛型，我们要在函数名前声明泛型参数。  
**扩展是静态解析的**
扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成
员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调
用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果
决定的。  
<pre>
open class C
class D: C()
fun C.foo() = "c"
fun D.foo() = "d"
fun printFoo(c: C) {
    println(c.foo())
} 
printFoo(D())
</pre>
这个例子会输出 "c"，因为调用的扩展函数只取决于参数 c 的声明类型，该类型是 C 类。
如果一个类定义有一个成员函数和一个扩展函数，而这两个函数又有相同的接收者类型、相
同的名字并且都适用给定的参数，这种情况总是取成员函数。  
如果我们调用 C 类型 c 的 c.foo() ，它将输出“member”，而不是“extension”。
当然，扩展函数重载同样名字但不同签名成员函数也完全可以
**可空接收者**
注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为
null，并且可以在函数体内检测 this == null ，这能让你在没有检测 null 的时候调用 Kotlin
中的toString()：检测发生在扩展函数的内部。  
<pre>
fun Any?.toString(): String {
    if (this == null) return "null"
        // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()
        // 解析为 Any 类的成员函数
    return toString()
}
</pre>

<p><strong>扩展属性</strong></p>
<pre>
val <t> List<t>.lastIndex: Int
    get() = size - 1
</t></t></pre>
注意：由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就
是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 getters/setters 定义。  
**伴生对象的扩展**
如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性：
<pre>
class MyClass {
    companion object { } // 将被称为 "Companion"
} 
fun MyClass.Companion.foo() {
    // ……
}
</pre>
就像伴生对象的其他普通成员，只需用类名作为限定符去调用他们  
**扩展的作用域**
大多数时候我们在顶层定义扩展，即直接在包里
<pre>
package foo.bar
fun Baz.goo() { …… }
</pre>
要使用所定义包之外的一个扩展，我们需要在调用方导入它：  
**扩展声明为成员**
在一个类内部你可以为另一个类声明扩展。在这样的扩展内部，有多个 隐式接收者 —— 其中
的对象成员可以无需通过限定符访问。扩展声明所在的类的实例称为 分发接收者，扩展方法
调用所在的接收者类型的实例称为 扩展接收者  
<pre>
class D {
    fun bar() { …… }
} 
class C {
    fun baz() { …… }
    fun D.foo() {
        bar() // 调用 D.bar
        baz() // 调用 C.baz
    } 
    fun caller(d: D) {
        d.foo() // 调用扩展函数
    }
}
</pre>
对于分发接收者和扩展接收者的成员名字冲突的情况，扩展接收者优先。要引用分发接收者
的成员你可以使用 限定的 this 语法  
<pre>
class C {
    fun D.foo() {
        toString() // 调用 D.toString()
        this@C.toString() // 调用 C.toString()
    }
}
</pre>
声明为成员的扩展可以声明为 open 并在子类中覆盖。这意味着这些函数的分发对于分发接
收者类型是虚拟的，但对于扩展接收者类型是静态的。  
<pre>
open class D {
} 
class D1 : D() {
} 
open class C {
    open fun D.foo() {
        println("D.foo in C")
    } 
    open fun D1.foo() {
        println("D1.foo in C")
    } 
    fun caller(d: D) {
        d.foo() // 调用扩展函数
    }
} 
class C1 : C() {
    override fun D.foo() {
        println("D.foo in C1")
    } 
    override fun D1.foo() {
        println("D1.foo in C1")
    }
} 
C().caller(D()) // 输出 "D.foo in C"
C1().caller(D()) // 输出 "D.foo in C1" —— 分发接收者虚拟解析
C().caller(D1()) // 输出 "D.foo in C" —— 扩展接收者静态解析
</pre>
### 数据类 ###
我们经常创建一些只保存数据的类。 在这些类中，一些标准函数往往是从数据机械推导而来
的。在 Kotlin 中，这叫做 数据类 并标记为 data  
<pre>
data class User(val name: String, val age: Int)
</pre>
编译器自动从主构造函数中声明的所有属性导出以下成员
<li>equals() / hashCode() 对；
</li><li>toString() 格式是 "User(name=John, age=42)" ；
</li><li>componentN() 函数 按声明顺序对应于所有属性；
</li><li>copy() 函数（见下文）  
为了确保生成的代码的一致性和有意义的行为，数据类必须满足以下要求：
</li><li>主构造函数需要至少有一个参数；
</li><li>主构造函数的所有参数需要标记为 val 或 var ；
</li><li>数据类不能是抽象、开放、密封或者内部的；
</li><li>（在1.1之前） 数据类只能实现接口。

此外，成员生成遵循关于成员继承的这些规则：  
</li><li>如果在数据类体中有显式实现 equals() 、 hashCode() 或者 toString() ，或者这些函
数在父类中有 final 实现，那么不会生成这些函数，而会使用现有函数；
</li><li>如果超类型具有 open 的 componentN() 函数并且返回兼容的类型， 那么会为数据类生
成相应的函数，并覆盖超类的实现。如果超类型的这些函数由于签名不兼容或者是 final
而导致无法覆盖，那么会报错；
</li><li>不允许为 componentN() 以及 copy() 函数提供显式实现。
自 1.1 起，数据类可以扩展其他类（示例请参见密封类） 。  
在 JVM 中，如果生成的类需要含有一个无参的构造函数，则所有的属性必须指定默认值。  
<pre>
data class User(val name: String = "", val age: Int = 0)
</pre>
**复制**
在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。 copy()
函数就是为此而生成。对于上文的 User 类，其实现会类似下面这样：  
<pre>
fun copy(name: String = this.name, age: Int = this.age) = User(name, age)
</pre>
这让我们可以写：
<pre>
val jack = User(name = "Jack", age = 1)
val olderJack = jack.copy(age = 2)
</pre>
数据类和解构声明  
为数据类生成的 Component 函数 使它们可在解构声明中使用：  
<pre>
val jane = User("Jane", 35)
val (name, age) = jane
println("$name, $age years of age") // 输出 "Jane, 35 years of age"
</pre>
**标准数据类  **
标准库提供了 Pair 和 Triple 。尽管在很多情况下命名数据类是更好的设计选择， 因为它
们通过为属性提供有意义的名称使代码更具可读性。   
#### 密封类 ####
密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型
时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量
只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。
要声明一个密封类，需要在类名前面添加 sealed 修饰符。虽然密封类也可以有子类，但是
所有子类都必须在与密封类自身相同的文件中声明。（在 Kotlin 1.1 之前， 该规则更加严
格：子类必须嵌套在密封类声明的内部） 。  
<pre>
sealed class Expr
data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()
object NotANumber : Expr()
</pre>
（上文示例使用了 Kotlin 1.1 的一个额外的新功能：数据类扩展包括密封类在内的其他类的可
能性。 ）
一个密封类是自身抽象的，它不能直接实例化并可以有抽象（abstract ） 成员。
密封类不允许有非- private 构造函数（其构造函数默认为 private ） 。
请注意，扩展密封类子类的类（间接继承者） 可以放在任何位置，而无需在同一个文件中。
使用密封类的关键好处在于使用 when 表达式 的时候，如果能够验证语句覆盖了所有情况，
就不需要为该语句再添加一个 else 子句了。当然，这只有当你用 when 作为表达式（使用
结果） 而不是作为语句时才有用  
<pre>
fun eval(expr: Expr): Double = when(expr) {
    is Const -> expr.number
    is Sum -> eval(expr.e1) + eval(expr.e2)
    NotANumber -> Double.NaN
    // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况
}
</pre>



























</li></t></int></int></li>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/23/kotlin基础（1）/" rel="next" title="kotlin基础（1）">
                <i class="fa fa-chevron-left"></i> kotlin基础（1）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/25/Kotlin基础（2）-类与对象-2/" rel="prev" title="Kotlin基础（2）-类与对象(2)">
                Kotlin基础（2）-类与对象(2) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table Des Matières
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Ensemble
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Clouse" />
          <p class="site-author-name" itemprop="name">Clouse</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">articles</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#类和继承"><span class="nav-number">1.</span> <span class="nav-text">类和继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类"><span class="nav-number">1.1.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数"><span class="nav-number">1.1.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数-1"><span class="nav-number">1.1.2.</span> <span class="nav-text">构造函数</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Clouse</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Thème -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
